Abstract

Este artigo tem como objetivo apresentar um experimento que consiste na implementação e validação de um conjunto de instruções customizadas para a arquitetura RISC-V utilizando o simulador gem5, como parte da avaliação da disciplina de tópicos em arquitetura e hardware.
O foco do experimento foi compreender a implementação do conjunto de instruções (ISA) e avaliar o comportamento dessas instruções customizadas no pipeline de execução. 
Foram criadas três instruções denominadas MXCLR, MXMAC e MXSTORE, responsáveis, respectivamente, por limpar registradores temporários, realizar a multiplicação e a soma em blocos 4×4 e armazenar o resultado em memória. 
As modificações foram realizadas nos módulos de decodificação e execução do gem5, escritas em C++17, e testadas com um programa em Assembly RISC-V .
A simulação foi conduzida no modo SE (System Emulation), validada por meio de logs de depuração cujos resultados confirmam o funcionamento esperado das instruções no pipeline, demonstrando a viabilidade de estender o ISA RISC-V, permitindo a evolução no processamento de operações matriciais.

Introdução
Nos últimos anos, o interesse por arquiteturas abertas e extensíveis tem crescido significativamente, impulsionado por demandas como a necessidade de eficiência energética, a necessidade de hardwares sob medida, com menor custo, e também, o aumento da especialização de aplicações — como inteligência artificial, criptografia e processamento de sinais. No contexto acadêmico, arquiteturas abertas como o RISC-V têm se tornado um padrão de pesquisa e ensino, permitindo a criação e experimentação de novas instruções, pipelines e aceleradores de forma acessível e reprodutível. 
Nesse contexto, o RISC-V se consolida como  principal plataforma para estudos de arquitetura e design de processadores personalizados e se destaca com o conjunto de instruções (ISA), que permite a adição de instruções customizadas e compatíveis  com o ecossistema. Essa flexibilidade possibilita a implementação de novos recursos a nível de processador, o que torna o RISC-V uma ferramenta importante na aceleração de estudos de computação de alto desempenho.
Simuladores de arquitetura, como o gem5 e o QEMU, desempenham papel essencial no processo de desenvolvimento e validação de instruções customizadas. O QEMU é amplamente utilizado para emulação funcional de alto desempenho, enquanto o gem5 oferece um modelo detalhado de microarquitetura, capaz de simular diferentes estágios do pipeline e componentes internos da CPU.
A proposta deste experimento é explorar o processo de extensão do ISA RISC-V por meio da implementação de um conjunto de instruções customizadas no simulador gem5, com o objetivo de compreender tanto os aspectos teóricos quanto práticos da integração de novas operações ao pipeline de execução. Foram desenvolvidas três instruções denominadas MXCLR, MXMAC e MXSTORE, voltadas à execução de operações de multiplicação e acumulação matricial (MAC) em blocos 4×4. Essas instruções atuam de forma integrada, permitindo limpar acumuladores, realizar produtos externos entre submatrizes e armazenar os resultados em memória, simulando um comportamento similar ao de extensões vetoriais.
O desenvolvimento do experimento envolveu etapas de configuração do ambiente RISC-V, criação de programas em linguagem C e Assembly, modificação do módulo de decodificação do gem5 e implementação do comportamento das instruções em C++. Para validar a proposta, foi desenvolvido um programa de teste que executa uma multiplicação de matrizes A×B, utilizando as novas instruções MX, e armazena o resultado em um buffer de memória. A simulação foi realizada em modo SE (System Emulation), e os resultados foram analisados a partir dos logs de depuração do gem5, com foco nos eventos de leitura e escrita de memória.
Os resultados obtidos demonstram o funcionamento correto das instruções implementadas, produzindo resultados numéricos coerentes com a operação de multiplicação-acumulação esperada (C = A×B). Além de validar o comportamento funcional das instruções MX, o trabalho evidencia a viabilidade e a utilidade didática da criação de instruções customizadas no ambiente RISC-V, fornecendo uma base prática para o estudo de extensões vetoriais e aceleração de operações matriciais em simuladores de arquitetura.

Fundamentação Teórica
A arquitetura RISC-V é um conjunto de instruções aberto e modular, caracteriza-se pela  flexibilidade e facilidade de implementação de extensão. Em contraposição a arquiteturas proprietárias, o RISC-V permite a criação de instruções customizadas de forma compatível com o ecossistema base, viabilizando experimentos em aceleração de tarefas  como operações vetoriais e multiplicações matriciais. A estrutura de cada instrução é definida por campos como opcode, funct3 e funct7, que determinam o tipo de operação e seus operandos.
A inclusão de instruções customizadas é um recurso amplamente explorado em pesquisas que buscam otimizar o desempenho de aplicações de inteligência artificial (IA), processamento digital de sinais (DSP) e computação de alto desempenho (HPC). Trabalhos recentes exploram as instruções específicas para multiply-accumulate (MAC), operações de convolução e multiplicações de matrizes, seja por meio de extensões ao RISC-V Vector Extension (RVV 1.0) ou pela criação de pipelines dedicados, essas abordagens demonstram que a inclusão de instruções especializadas pode reduzir significativamente o número de ciclos por operação e simplificar a lógica de controle no software.
Para avaliação dessas modificações em nível microarquitetural, simuladores como o QEMU e o gem5 são amplamente utilizados. O QEMU é adequado para execução funcional e rápida, mas possui abstração limitada da microarquitetura. Já o gem5 oferece um ambiente detalhado e extensível, capaz de modelar desde caches até pipelines customizados, permitindo observar os efeitos diretos das modificações no ISA, essa foi a principal razão pela qual o gem5 foi escolhido para este experimento.
Além disso, as extensões vetoriais RISC-V (RVV) introduzem mecanismos para processar dados em larga escala de forma paralela, baseadas em registradores vetoriais de largura variável. Embora o projeto atual não utilize diretamente o RVV, a proposta das instruções MX aproxima-se conceitualmente desse paradigma, pois implementa manualmente um bloco de multiplicação e acumulação 4×4, servindo como prova de conceito para futuras extensões vetoriais personalizadas.
